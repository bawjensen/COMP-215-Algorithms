#include "bTree.h"// ======================================================================bTree::bTree()								//CTOR//..........................................//POST: new bTree is created with no root{	this->root = 0;	}//CTOR// ======================================================================bTree::bTree(string someText)//..........................................//POST: new bTree is created with a root with known text{	this->root = new Node(someText);		// NOTE:  we must use the functions in the Node class to change things!	root->AppendLeft ( 0 );	root->AppendRight( 0 );}//CTOR// ======================================================================void bTree::recursiveDTOR(Node* current) {	if (current->LChild() != 0) {		this->recursiveDTOR(current->LChild());	}	if (current->RChild() != 0) {		this->recursiveDTOR(current->RChild());	}	cout << current->GetText() << " ";	delete current;}bTree::~bTree()								//DTOR{	cout << "Starting delete... DELETED: ";	this->recursiveDTOR(this->root);	cout << "...done." << endl;	} //DTOR	// ======================================================================// inline in bTree.h// Node* GetRoot(void) const   /* inline */ { return this->root; }// ======================================================================void bTree::InsertItem(string newText)//..........................................//POST: bTree with newNode inserted holding the newText{	Node* newNode = new Node(newText);		// empty tree?	if (this->GetRoot() == 0)		this->root = newNode;		else	{		// ok, we'll have to find where to insert this new item		Node* parent;		Node* cur;				cur = this->GetRoot();		while (cur)		{			parent = cur;						string currentText = cur->GetText();						if (newText == currentText ) {				cout << "Item " << newText << " is already in tree; insert aborted." << endl;				return;			}						else if (newText < currentText)				cur = cur->LChild();						else				cur = cur->RChild();		}				// position located; now insert		if (newText < parent->GetText() )			parent->AppendLeft(newNode);		else			parent->AppendRight(newNode);			} // else} // end insertItem// ======================================================================void bTree::printInorder(Node* current) const//..........................................// POST: Displays data in inorder fashion{	if (current->LChild() != 0) {		this->printInorder(current->LChild());	}	cout << " " << current->GetText() << " ";	if (current->RChild() != 0) {		this->printInorder(current->RChild());	}}// ======================================================================void bTree::printPreorder(Node* current) const//..........................................// POST: Displays data in inorder fashion{	cout << " " << current->GetText() << " ";	if (current->LChild() != 0) {		this->printPreorder(current->LChild());	}	if (current->RChild() != 0) {		this->printPreorder(current->RChild());	}}// ======================================================================void bTree::printPostorder(Node* current) const//..........................................// POST: Displays data in inorder fashion{	if (current->LChild() != 0) {		this->printPostorder(current->LChild());	}	if (current->RChild() != 0) {		this->printPostorder(current->RChild());	}	cout << " " << current->GetText() << " ";}// ======================================================================short bTree::treeHeight(Node* current, short depth) const//..........................................// RETURNS: binary tree height where "height" will be here defined as// number of NODES traversed from the root to the lowest leaf{	if (current == 0) {		return depth;	}	else {		return max(this->treeHeight(current->LChild(), depth+1),				this->treeHeight(current->RChild(), depth+1));	}}// ======================================================================short bTree::leafCount(Node* current) const//..........................................// RETURNS: number of leaf nodes in the tree{ // UGLY!	if (current->RChild() == 0 and current->LChild() == 0) {		return 1;	}	else if (current->LChild() == 0) {		return 0 + this->leafCount(current->RChild());	}	else if (current->RChild() == 0) {		return 0 + this->leafCount(current->LChild());	}	else {		return this->leafCount(current->LChild()) + this->leafCount(current->RChild());	}}// ======================================================================bool bTree::search4Item(string key, Node* current) const//..........................................// RETURNS: true if key was found in the tree{	if (key == current->GetText()) {		return true;	}	else if (key < current->GetText() and current->LChild() != 0) {		return this->search4Item(key, current->LChild());	}	else if (key > current->GetText() and current->RChild() != 0) {		return this->search4Item(key, current->RChild());	}	else {		return false;	}}